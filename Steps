GOALS:

1. How to interact with 3rd party APIs (eg. Fake Store Api)
   Product service (1st requirement)
    - add product
    - get list of products
2. Implement facade (3rd party client class) for rest template methods
3. Create global exception handler

Takeaways:
 - @PathVariable: used to map the request URI to a Java method argument
 - @RequestBody: used to map the request body to a Java object
 - Jackson library: used to convert JSON to Java object and vice versa
 - RestTemplate: used to make HTTP requests to 3rd party APIs
 - ResponseEntity: used to return HTTP status code and response body
 - MultiValueMap: used to send form data or headers in HTTP request body
 - Conversion from "list" of json objects to "list" of java objects gives an error because of generics. Generics by default does not remember the type at runtime. Hence, instead of using "List<Class_Name>", we use "Class_Name[]".
 - ResponseEntity's getBody(): used for getting the response body
 - @ControllerAdvice: used to handle exceptions globally
 - Hibernate is an ORM (Object Relational Mapping) library
 - Repository is a DAO (Data Access Object) pattern which is responsible for interacting with the database
 - Application Flow: Client -> Controller -> Service -> Repository -> JPA -> Hibernate -> JDBC -> MySQL Driver -> Database
 - @SpringBootApplication(exclude={DataSourceAutoConfiguration.class}): Used to by-pass spring hibernate library's datasource configurations
 - @Qualifier: used to specify which bean to use when there are multiple beans of the same type
 - @ManyToOne(mappedBy = "<parent-entity-attribute-name>"): used to tell jpa that the relationship between the two entities is many to one. The mappedBy attribute is used to tell jpa that the relationship is already mapped by the parent entity. This is used when we don't want to create a foreign key column in the child entity table. It is not applicable for one-to-one and many-to-many relationships.
 - @ManyToOne(cascade = CascadeType.ALL): used to tell jpa that the relationship between the two entities is many to one. The cascade type is used to tell jpa to perform the same operation on the child entity as the parent entity. For example, if we delete a parent entity, then the child entity will also be deleted.
 - UUID: version 4 and 7. version 4 is random and version 7 is time based. 128 bit long. 32 hexadecimal digits. 4 bits for version and 2 bits for variant. 122 bits for random number.
 - @GeneratedValue(strategy = GenerationType.AUTO): used to tell jpa to automatically generate the primary key value
 - @GeneratedValue(strategy = GenerationType.IDENTITY): used to tell jpa to automatically generate the primary key value using the database's auto increment feature
 - Lazy Loading: used to tell jpa to load the child entity ("Has-A" or "Association" relationship) ONLY WHEN IT IS REQUIRED. For example, if we have a parent entity and a child entity, then the child entity will be loaded only when we call the getter method of the child entity in the parent entity. It's better in performance than eager loading and mostly we use this type of loading only. We use fetch = FetchType.LAZY to implement lazy loading.
 - Eager Loading: used to tell jpa to load the child entity ("Has-A" or "Association" relationship) along with the parent entity. For example, if we have a parent entity and a child entity, then the child entity will be loaded along with the parent entity. By default, jpa uses eager loading. We can change it to lazy loading by using the @ManyToOne(fetch = FetchType.LAZY) annotation.
 - Hibernate N+1 problem occurs when you use FetchType.LAZY for your entity associations. If you perform a query to select n-entities and if you try to call any access method of your entity's lazy association, Hibernate will perform n-additional queries to load lazily fetched objects. For example, if we have a parent entity and a child entity, then the child entities will be fetched in n+1 queries.
 - @Fetch(FetchMode.SUBSELECT / JOIN / SELECT): used to tell hibernate to fetch the child entities ("Has-A" or "Association" relationship) in a single query. This is used to avoid the n+1 problem. For example, if we have a parent entity and a child entity, then the child entities will be fetched in a single query. By default, hibernate uses n+1 queries to fetch the child entities. We can change it to a single query by using this annotation.
 - If the Hibernate annotation @Fetch is not present on a field, then FetchMode is JOIN if FetchType is EAGER and FetchMode is SELECT if FetchType is LAZY.
 - If you use @Transactional on a spring test class, then the changes made to the database will be rolled back after the test is completed. This is done to avoid the changes made to the database during the test to affect the actual database. If you don't want the database to get rolled back during the test then you will explicitly have to use @Rollback(false) annotation or if you want to commit use @Commit annotation.
 - Between FetchType and FetchMode, FetchMode is given more priority. For example, if we use @ManyToOne(fetch = FetchType.LAZY) and @Fetch(FetchMode.JOIN), then the child entities will be fetched in a single query.
 - Optional<>: used to avoid NullPointerException. If the object is present, then it will return the object. If the object is not present, then it will return null.
 - JPA Queries are simple english queries which are converted to SQL queries by the JPA provider (Hibernate).
 - @Query(<sql-query>): used to write custom JPA queries. We can use this annotation to write complex queries which are not possible using the JPA method naming convention.

WAYS TO REPRESENT INHERITANCE IN JPA:

 - @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS): used to tell jpa to create a table for each class in the inheritance hierarchy
 - @Inheritance(strategy = InheritanceType.SINGLE_TABLE): used to tell jpa to create a single table for all the classes in the inheritance hierarchy. May lead to a sparse table.
 - @DiscriminatorColumn(name = "<discriminator-column-name, eg. user_type>", discriminatorType = DiscriminatorType.INTEGER): used to tell jpa to create a column in the table which will store the class name of the object
 - @DiscriminatorValue("<discriminator-value, eg. 1>"): used to tell jpa to store the value of the discriminator column as the specified value. Basically the way we map enums in the database for efficiency.
 - @Inheritance(strategy = InheritanceType.JOINED): used to tell jpa to create a table for each class in the inheritance hierarchy and also create a table for the parent class. The parent class table will have the common attributes of all the child classes. The child class tables will have the attributes specific to them. The child class tables will have a foreign key to the parent class table.
 - @PrimaryKeyJoinColumn(name = "<foreign-key-column-name, eg. user_id>"): used to tell jpa to create a foreign key column in the child class table which will refer to the primary key column of the parent class table
 - @MappedSuperclass: used to tell jpa to not create a table for the class as this class will be used as a parent class for other classes. The attributes of this class will be inherited by the child classes. The child classes will have their own tables. You can't use @Entity and @MappedSuperclass together.

SCHEMA VERSIONING AND MIGRATION:

 - If you use spring.jpa.hibernate.ddl-auto=validate, then hibernate will validate the schema with the entity classes. If the schema is not valid, then hibernate will throw an exception.
   That means if you change the entity class, then you will have to manually update the schema in the database, else it will throw an exception.
 - To manually create the DDL script you can make use of JPA Buddy which will generate an SQL script for you. Click on JPA Explorer -> '+' sign -> Generate DDL by entities -> DB Schema initialization. This way you can have initial DDL script.
 - For any modifications in the entity classes you again Click on JPA Explorer -> '+' sign -> Generate DDL by entities -> Existing DB Update (Diff). This DDL script will contain queries related only to the modifications you made to the entity class.
 - So this way now you have different versions of your schema. Now you'll have the freedom to rollback as well if you want to.
 - You must use "Flyway" OR "Liquibase" maven dependencies. These dependencies will help you maintain the schema versioning and migration by creating the initial schema, updating the schema, rolling back the schema to a previous version, etc.

TESTING

 - Unit Testing -> Integration Testing -> Functional Testing
 - Unit Testing: used to test the smallest part of the code. For example, a method or a class. We test the method or class in isolation. We don't test the interaction between the methods or classes. We use mock objects to test the method or class in isolation.
 - Integration Testing: used to test the interaction between the methods or classes. We test the interaction between the methods or classes. We don't test the method or class in isolation. We use the actual objects to test the interaction between the methods or classes.
 - Functional Testing: used to test the functionality of the application. We test the application as a whole, i.e, from end-to-end. We test the application from the user's perspective. We test the application's functionality, usability, and user interface.
 - @SpringbootTest: used to tell JUnit that the class is a spring boot test class
 - @Test: used to tell JUnit that the method is a test method
 - Good practice of naming the test methods: test<method-name>_when<condition>_then<expected-behavior>
 - Unit Testing: It has 3 phases (A-A-A / C-C-C) :-
    1) Arrange / Create: To set up the test. We create object of the class whose method is to be tested
    2) Act / Call: To perform the test. We call the method to be tested
    3) Assert / Check: To verify the result. We check the result. For eg., assert(<expression>) / assertEquals(expected, actual) is used to compare the expected and actual values
 - Frameworks we mainly use for Unit Testing: JUnit5 and Mockito
 - @DisplayName("<test-case-name>"): used to give a custom name to the test case for better readability and understanding
 - assertThrows(<exception-class>, () -> <method-call>): used to tell JUnit that the method should throw the specified exception which we are expecting.
 - Test Suite: used to run multiple test classes together. We can create a test suite by creating a class and adding the test classes to it. We can run the test suite to run all the test classes together.
 - Mocking: used to create a fake object of a class. We use mock objects to test the method or class in isolation.
    - @Mock: used to create a mock object. We use @InjectMocks annotation to inject the mock object into the actual object. For eg., Student class need Pen class object to perform its write operation. So, we mock the Pen class and inject it into the Student class.
    - @MockBean: used to create a mock object of a class. We use mock objects to test the method or class in isolation. We use @MockBean annotation to create a mock object. We use @Autowired annotation to inject the mock object into the actual object.
 - @WebMvcTest(<controller-class-name>.class): We use this annotation to test the web layer of the application. We use this annotation to test the controller class in isolation, to test the interaction between the controller class and the service class or repository class or database.
 - mockMvc.perform(get("/<url>")): We use this method to perform the HTTP request like GET, POST, PUT, DELETE requests.
 - ObjectMapper: It is a package provided by Jackson library to convert the Java object to JSON and vice versa. We use this class to convert the response body to a Java object.
 - Doubles:
     - Mocks: hard code the methods
     - Stubs: hard code the behavior
     - Fakes: hard code the major systems
 - Hamcrest Matchers: used to write assertions in a more readable way. For example, assertThat(actual, is(equalTo(expected))) is used to compare the expected and actual values.
 - AssertJ Library: used to write assertions in a more readable way. For example, assertThat(actual).isEqualTo(expected) is used to compare the expected and actual values.
 - ArgumentCaptor: used to capture the argument of a method. We use this class to verify the argument of a method. We use @Captor annotation to create an argument captor.
















