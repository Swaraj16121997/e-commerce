GOALS:

1. How to interact with 3rd party APIs (eg. Fake Store Api)
   Product service (1st requirement)
    - add product
    - get list of products
2. Implement facade (3rd party client class) for rest template methods
3. Create global exception handler

Takeaways:
 - @PathVariable: used to map the request URI to a Java method argument
 - @RequestBody: used to map the request body to a Java object
 - Jackson library: used to convert JSON to Java object and vice versa
 - RestTemplate: used to make HTTP requests to 3rd party APIs
 - ResponseEntity: used to return HTTP status code and response body
 - MultiValueMap: used to send form data or headers in HTTP request body
 - Conversion from "list" of json objects to "list" of java objects gives an error because of generics. Generics by default does not remember the type at runtime. Hence, instead of using "List<Class_Name>", we use "Class_Name[]".
 - ResponseEntity's getBody(): used for getting the response body
 - @ControllerAdvice: used to handle exceptions globally
 - Hibernate is an ORM (Object Relational Mapping) library
 - Repository is a DAO (Data Access Object) pattern which is responsible for interacting with the database
 - Application Flow: Client -> Controller -> Service -> Repository -> JPA -> Hibernate -> JDBC -> MySQL Driver -> Database
 - @SpringBootApplication(exclude={DataSourceAutoConfiguration.class}): Used to by-pass spring hibernate library's datasource configurations
 - @Qualifier: used to specify which bean to use when there are multiple beans of the same type
 - @ManyToOne(mappedBy = "<parent-entity-attribute-name>"): used to tell jpa that the relationship between the two entities is many to one. The mappedBy attribute is used to tell jpa that the relationship is already mapped by the parent entity. This is used when we don't want to create a foreign key column in the child entity table. It is not applicable for one-to-one and many-to-many relationships.
 - @ManyToOne(cascade = CascadeType.ALL): used to tell jpa that the relationship between the two entities is many to one. The cascade type is used to tell jpa to perform the same operation on the child entity as the parent entity. For example, if we delete a parent entity, then the child entity will also be deleted.
 - UUID: version 4 and 7. version 4 is random and version 7 is time based. 128 bit long. 32 hexadecimal digits. 4 bits for version and 2 bits for variant. 122 bits for random number.
 - @GeneratedValue(strategy = GenerationType.AUTO): used to tell jpa to automatically generate the primary key value
 - @GeneratedValue(strategy = GenerationType.IDENTITY): used to tell jpa to automatically generate the primary key value using the database's auto increment feature
 - Lazy Loading: used to tell jpa to load the child entity ("Has-A" or "Association" relationship) ONLY WHEN IT IS REQUIRED. For example, if we have a parent entity and a child entity, then the child entity will be loaded only when we call the getter method of the child entity in the parent entity. It's better in performance than eager loading and mostly we use this type of loading only. We use fetch = FetchType.LAZY to implement lazy loading.
 - Eager Loading: used to tell jpa to load the child entity ("Has-A" or "Association" relationship) along with the parent entity. For example, if we have a parent entity and a child entity, then the child entity will be loaded along with the parent entity. By default, jpa uses eager loading. We can change it to lazy loading by using the @ManyToOne(fetch = FetchType.LAZY) annotation.
 - Hibernate N+1 problem occurs when you use FetchType.LAZY for your entity associations. If you perform a query to select n-entities and if you try to call any access method of your entity's lazy association, Hibernate will perform n-additional queries to load lazily fetched objects. For example, if we have a parent entity and a child entity, then the child entities will be fetched in n+1 queries.
 - @Fetch(FetchMode.SUBSELECT / JOIN / SELECT): used to tell hibernate to fetch the child entities ("Has-A" or "Association" relationship) in a single query. This is used to avoid the n+1 problem. For example, if we have a parent entity and a child entity, then the child entities will be fetched in a single query. By default, hibernate uses n+1 queries to fetch the child entities. We can change it to a single query by using this annotation.
 - If the Hibernate annotation @Fetch is not present on a field, then FetchMode is JOIN if FetchType is EAGER and FetchMode is SELECT if FetchType is LAZY.
 - If you use @Transactional on a spring test class, then the changes made to the database will be rolled back after the test is completed. This is done to avoid the changes made to the database during the test to affect the actual database. If you don't want the database to get rolled back during the test then you will explicitly have to use @Rollback(false) annotation or if you want to commit use @Commit annotation.
 - Between FetchType and FetchMode, FetchMode is given more priority. For example, if we use @ManyToOne(fetch = FetchType.LAZY) and @Fetch(FetchMode.JOIN), then the child entities will be fetched in a single query.
 - Optional<>: used to avoid NullPointerException. If the object is present, then it will return the object. If the object is not present, then it will return null.
 - JPA Queries are simple english queries which are converted to SQL queries by the JPA provider (Hibernate).

WAYS TO REPRESENT INHERITANCE IN JPA:

 - @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS): used to tell jpa to create a table for each class in the inheritance hierarchy
 - @Inheritance(strategy = InheritanceType.SINGLE_TABLE): used to tell jpa to create a single table for all the classes in the inheritance hierarchy. May lead to a sparse table.
 - @DiscriminatorColumn(name = "<discriminator-column-name, eg. user_type>", discriminatorType = DiscriminatorType.INTEGER): used to tell jpa to create a column in the table which will store the class name of the object
 - @DiscriminatorValue("<discriminator-value, eg. 1>"): used to tell jpa to store the value of the discriminator column as the specified value. Basically the way we map enums in the database for efficiency.
 - @Inheritance(strategy = InheritanceType.JOINED): used to tell jpa to create a table for each class in the inheritance hierarchy and also create a table for the parent class. The parent class table will have the common attributes of all the child classes. The child class tables will have the attributes specific to them. The child class tables will have a foreign key to the parent class table.
 - @PrimaryKeyJoinColumn(name = "<foreign-key-column-name, eg. user_id>"): used to tell jpa to create a foreign key column in the child class table which will refer to the primary key column of the parent class table
 - @MappedSuperclass: used to tell jpa to not create a table for the class as this class will be used as a parent class for other classes. The attributes of this class will be inherited by the child classes. The child classes will have their own tables. You can't use @Entity and @MappedSuperclass together.