------------------------------------------BASICS---------------------------------------------------------

DELIVERABLES:

1. How to interact with 3rd party APIs (eg. Fake Store Api)
   Product service (1st requirement): CRUD operations
2. Implement facade (3rd party client class) for rest template methods
3. Create global exception handler
4. How to interact with databases (eg. MySQL)
5. Test the application using JUnit and Mockito
6. User service (2nd requirement): CRUD operations
7. How to authenticate and authorize the user using OAuth 2.0
8. How to use JWT (JSON Web Token) for authorization
9. How product service interacts with user service for authorization.
10. How to deploy the application on AWS (Amazon Web Services)
11. Payment Service (3rd requirement): integrating with 3rd party payment gateways (Razorpay and Stripe)

GENERAL NOTES:

 - @PathVariable: used to map the request URI to a Java method argument
 - @RequestBody: used to map the request body to a Java object
 - Jackson library: used to convert JSON to Java object and vice versa
 - RestTemplate: used to make HTTP requests to 3rd party APIs
 - ResponseEntity: used to return HTTP status code and response body
 - MultiValueMap: used to send form data or headers in HTTP request body
 - Conversion from "list" of json objects to "list" of java objects gives an error because of generics. Generics by default does not remember the type at runtime. Hence, instead of using "List<Class_Name>", we use "Class_Name[]".
 - ResponseEntity's getBody(): used for getting the response body
 - @ControllerAdvice: used to handle exceptions globally
 - Hibernate is an ORM (Object Relational Mapping) library
 - Repository is a DAO (Data Access Object) pattern which is responsible for interacting with the database
 - Application Flow: Client -> Controller -> Service -> Repository -> JPA -> Hibernate -> JDBC -> MySQL Driver -> Database
 - @SpringBootApplication(exclude={DataSourceAutoConfiguration.class}): Used to by-pass spring hibernate library's datasource configurations
 - @Qualifier: used to specify which bean to use when there are multiple beans of the same type
 - @ManyToOne(mappedBy = "<parent-entity-attribute-name>"): used to tell jpa that the relationship between the two entities is many to one. The mappedBy attribute is used to tell jpa that the relationship is already mapped by the parent entity. This is used when we don't want to create a foreign key column in the child entity table. It is not applicable for one-to-one and many-to-many relationships.
 - @ManyToOne(cascade = CascadeType.ALL): used to tell jpa that the relationship between the two entities is many to one. The cascade type is used to tell jpa to perform the same operation on the child entity as the parent entity. For example, if we delete a parent entity, then the child entity will also be deleted.
 - UUID: version 4 and 7. version 4 is random and version 7 is time based. 128 bit long. 32 hexadecimal digits. 4 bits for version and 2 bits for variant. 122 bits for random number.
 - @GeneratedValue(strategy = GenerationType.AUTO): used to tell jpa to automatically generate the primary key value
 - @GeneratedValue(strategy = GenerationType.IDENTITY): used to tell jpa to automatically generate the primary key value using the database's auto increment feature
 - Lazy Loading: used to tell jpa to load the child entity ("Has-A" or "Association" relationship) ONLY WHEN IT IS REQUIRED. For example, if we have a parent entity and a child entity, then the child entity will be loaded only when we call the getter method of the child entity in the parent entity. It's better in performance than eager loading and mostly we use this type of loading only. We use fetch = FetchType.LAZY to implement lazy loading.
 - Eager Loading: used to tell jpa to load the child entity ("Has-A" or "Association" relationship) along with the parent entity. For example, if we have a parent entity and a child entity, then the child entity will be loaded along with the parent entity. By default, jpa uses eager loading. We can change it to lazy loading by using the @ManyToOne(fetch = FetchType.LAZY) annotation.
 - Hibernate N+1 problem occurs when you use FetchType.LAZY for your entity associations. If you perform a query to select n-entities and if you try to call any access method of your entity's lazy association, Hibernate will perform n-additional queries to load lazily fetched objects. For example, if we have a parent entity and a child entity, then the child entities will be fetched in n+1 queries.
 - @Fetch(FetchMode.SUBSELECT / JOIN / SELECT): used to tell hibernate to fetch the child entities ("Has-A" or "Association" relationship) in a single query. This is used to avoid the n+1 problem. For example, if we have a parent entity and a child entity, then the child entities will be fetched in a single query. By default, hibernate uses n+1 queries to fetch the child entities. We can change it to a single query by using this annotation.
 - If the Hibernate annotation @Fetch is not present on a field, then FetchMode is JOIN if FetchType is EAGER and FetchMode is SELECT if FetchType is LAZY.
 - If you use @Transactional on a spring test class, then the changes made to the database will be rolled back after the test is completed. This is done to avoid the changes made to the database during the test to affect the actual database. If you don't want the database to get rolled back during the test then you will explicitly have to use @Rollback(false) annotation or if you want to commit use @Commit annotation.
 - Between FetchType and FetchMode, FetchMode is given more priority. For example, if we use @ManyToOne(fetch = FetchType.LAZY) and @Fetch(FetchMode.JOIN), then the child entities will be fetched in a single query.
 - Optional<>: used to avoid NullPointerException. If the object is present, then it will return the object. If the object is not present, then it will return null.
 - JPA Queries are simple english queries which are converted to SQL queries by the JPA provider (Hibernate).
 - @Query(<sql-query>): used to write custom JPA queries. We can use this annotation to write complex queries which are not possible using the JPA method naming convention.
 - @Configuration: used to tell spring that the class is a configuration class. It is used for java based configuration.
 - TRIVIAL FLAW TO AVOID: Always remember to implement exception handling whenever you are coding (mainly during service layer).

WAYS TO REPRESENT INHERITANCE IN JPA:

 - @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS): used to tell jpa to create a table for each class in the inheritance hierarchy
 - @Inheritance(strategy = InheritanceType.SINGLE_TABLE): used to tell jpa to create a single table for all the classes in the inheritance hierarchy. May lead to a sparse table.
 - @DiscriminatorColumn(name = "<discriminator-column-name, eg. user_type>", discriminatorType = DiscriminatorType.INTEGER): used to tell jpa to create a column in the table which will store the class name of the object
 - @DiscriminatorValue("<discriminator-value, eg. 1>"): used to tell jpa to store the value of the discriminator column as the specified value. Basically the way we map enums in the database for efficiency.
 - @Inheritance(strategy = InheritanceType.JOINED): used to tell jpa to create a table for each class in the inheritance hierarchy and also create a table for the parent class. The parent class table will have the common attributes of all the child classes. The child class tables will have the attributes specific to them. The child class tables will have a foreign key to the parent class table.
 - @PrimaryKeyJoinColumn(name = "<foreign-key-column-name, eg. user_id>"): used to tell jpa to create a foreign key column in the child class table which will refer to the primary key column of the parent class table
 - @MappedSuperclass: used to tell jpa to not create a table for the class as this class will be used as a parent class for other classes. The attributes of this class will be inherited by the child classes. The child classes will have their own tables. You can't use @Entity and @MappedSuperclass together.

SCHEMA VERSIONING AND MIGRATION:

 - If you use spring.jpa.hibernate.ddl-auto=validate, then hibernate will validate the schema with the entity classes. If the schema is not valid, then hibernate will throw an exception.
   That means if you change the entity class, then you will have to manually update the schema in the database, else it will throw an exception.
 - To manually create the DDL script you can make use of JPA Buddy which will generate an SQL script for you. Click on JPA Explorer -> '+' sign -> Generate DDL by entities -> DB Schema initialization. This way you can have initial DDL script.
 - For any modifications in the entity classes you again Click on JPA Explorer -> '+' sign -> Generate DDL by entities -> Existing DB Update (Diff). This DDL script will contain queries related only to the modifications you made to the entity class.
 - So this way now you have different versions of your schema. Now you'll have the freedom to rollback as well if you want to.
 - You must use "Flyway" OR "Liquibase" maven dependencies. These dependencies will help you maintain the schema versioning and migration by creating the initial schema, updating the schema, rolling back the schema to a previous version, etc.

TESTING

 - Unit Testing -> Integration Testing -> Functional Testing
 - Unit Testing: used to test the smallest part of the code. For example, a method or a class. We test the method or class in isolation. We don't test the interaction between the methods or classes. We use mock objects to test the method or class in isolation.
 - Integration Testing: used to test the interaction between the methods or classes. We test the interaction between the methods or classes. We don't test the method or class in isolation. We use the actual objects to test the interaction between the methods or classes.
 - Functional Testing: used to test the functionality of the application. We test the application as a whole, i.e, from end-to-end. We test the application from the user's perspective. We test the application's functionality, usability, and user interface.
 - @SpringbootTest: used to tell JUnit that the class is a spring boot test class
 - @Test: used to tell JUnit that the method is a test method
 - Good practice of naming the test methods: test<method-name>_when<condition>_then<expected-behavior>
 - Unit Testing: It has 3 phases (A-A-A / C-C-C) :-
    1) Arrange / Create: To set up the test. We create object of the class whose method is to be tested
    2) Act / Call: To perform the test. We call the method to be tested
    3) Assert / Check: To verify the result. We check the result. For eg., assert(<expression>) / assertEquals(expected, actual) is used to compare the expected and actual values
 - Frameworks we mainly use for Unit Testing: JUnit5 and Mockito
 - @DisplayName("<test-case-name>"): used to give a custom name to the test case for better readability and understanding
 - assertThrows(<exception-class>, () -> <method-call>): used to tell JUnit that the method should throw the specified exception which we are expecting.
 - Test Suite: used to run multiple test classes together. We can create a test suite by creating a class and adding the test classes to it. We can run the test suite to run all the test classes together.
 - @Suite annotation is used to tell JUnit that the class is a test suite class and @SelectClasses({<test-class1-name>.class, <test-class2-name>.class}...) annotation is used to tell JUnit to run the specified test classes in that test suite class.
 - @SelectPackages({"test-package1-name", "test-package2-name", ...}): used to tell JUnit to run all the test classes in the specified packages.
 - Mocking: used to create a fake object of a class. We use mock objects to test the method or class in isolation.
    - @Mock: used to create a mock object. We use @InjectMocks annotation to inject the mock object into the actual object. For eg., Student class need Pen class object to perform its write operation. So, we mock the Pen class and inject it into the Student class.
    - @MockBean: used to create a mock object of a class. We use mock objects to test the method or class in isolation. We use @MockBean annotation to create a mock object. We use @Autowired annotation to inject the mock object into the actual object.
 - @WebMvcTest(<controller-class-name>.class): We use this annotation to test the web layer of the application. We use this annotation to test the controller class in isolation, to test the interaction between the controller class and the service class or repository class or database.
 - mockMvc.perform(get("/<url>")): We use this method to perform the HTTP request like GET, POST, PUT, DELETE requests.
 - ObjectMapper: It is a package provided by Jackson library to convert the Java object to JSON and vice versa. We use this class to convert the response body to a Java object.
 - Doubles:
     - Mocks: hard code the methods
     - Stubs: hard code the behavior
     - Fakes: hard code the major systems
 - Hamcrest Matchers: used to write assertions in a more readable way. For example, assertThat(actual, is(equalTo(expected))) is used to compare the expected and actual values.
 - AssertJ Library: used to write assertions in a more readable way. For example, assertThat(actual).isEqualTo(expected) is used to compare the expected and actual values.
 - ArgumentCaptor: used to capture the argument of a method. We use this class to verify the argument of a method. We use @Captor annotation to create an argument captor.

AUTHENTICATION & AUTHORIZATION

 - OAuth: used to authenticate and authorize the user. It is an open standard for access delegation, commonly used as a way for Internet users to grant websites or applications access to their information on other websites but without giving them the passwords. OAuth 2.0 is the industry-standard protocol for authorization which is currently most commonly used.
 - Authorization Server: used to authenticate the user and provide the access token to the client (any website which conducts the OAuth). The client uses the access token to access the resources of the resource server.
 - Resource Server: used to provide the resources to the client. It cross-verifies the access token provided by the client, with the authorization server and then provides the resources to the client.
 - Mostly all companies have their own authorization server for their resource server. For example, Google has its own authorization server for its resource server. Some companies use third-party authorization servers like Okta, Ory-Hydra, etc.
 - How OAuth works:
    1) The client requests authorization from the user (After we authenticate ourselves using our Google login credentials on a website, the website requests authorization from us to access resources of our Google account.)
    2) The user authorizes the client (We authorize the website to access our Google account.)
    3) The client requests an access token from the authorization server (The website requests an access token from Google's authorization server)
    4) The authorization server provides an access token to the client (Google's authorization server provides an access token to the website.)
    5) The client requests the resource from the resource server (The website requests the resource(s) from Google's resource server using the access token.)
    6) The resource server provides the resource to the client (Google's resource server provides the resource to the website.)

 - Why we need JWT (JSON Web Token)? Because, OAuth 2.0 does not specify the format of the access token. It only specifies the way to get the access token. So, we need a format to represent the access token. If each token is not formatted in a standard way, then for each request, out of millions of requests, the authorization server will have to make a database call everytime in order to verify the token. Hence, this method is inefficient and time consuming when we are dealing with millions of requests. Here's where JWT comes into picture.
 - JWT is a format to represent the access token, i.e, the token itself contains the required information which now makes it possible for the resource server to validate the token itself. The authorization server no more needs to make a call to the database everytime for each request.
 - JWT has 3 parts: Header, Payload, Signature. The header contains the type of the token and the algorithm used to sign the token. The payload contains the claims (the data that user wants to share, for eg., username, session, expiry, etc.). The signature is a data (usually combination of header and payload) encrypted using a secret key, which is used to verify that the sender of the token is who it says it is and to ensure that the message wasn't changed along the way. All these 3 parts are encoded in base64 format and concatenated with a dot.
 - The working flow of JWt is as follows:
    1) The secret key is shared between the user or client (on behalf of the user) and the resource server.
    2) After the user receives the access token from the authorization server, it sends the access token to the resource server.
    3) The resource server decodes the access token. It first generates a signature by itself using the header and payload of the decoded access token and the shared secret key it already has, then it compares the generated signature with the signature present in the decoded access token. If both the signatures match, then the access token is valid and the resource server provides the resource to the user or the client (on behalf of the user). Hence, like this, the resource server is able to validate that the token which was provided to the user was provided by the authorization server and was not tampered with.
 - Can we use a custom formatted token for authorization? Yes, we can use. Using JWT is not mandatory but JWT is the most widely used format to represent the access token. The problem with custom formatted token is that the resource server will have to make a database call everytime for each request in order to validate the token.

 - spring-boot-starter-security dependency: used to enable the security in all the resource endpoints of the application by default. It provides the default security configuration like default login page, logout page, etc.
 - As by default spring security is enabled, we need to disable it in order to use our own custom security configuration. Hence we create out own filtering criteria.
 - Whenever you create a configuration class each of the methods have to be annotated with @Bean. This is because, the methods are used to create the beans (IOC) and these beans are then used internally by the spring framework wherever required because we don't know where the beans are to be autowired and used.
 - IOC (Inversion Of Control): It is a design principle in which the control of the object creation is transferred to a container or framework. It is the opposite of the normal control flow of the program. In normal control flow, the programmer creates the objects and uses them. In IOC, the container or framework creates the objects and gives them to the programmer to use. The container or framework which is responsible for creating the objects and managing their life cycle is called the IOC container or framework.
 - Difference between @Bean and @Component: Use @Bean when you want to create a bean of a class which is not under your control. Use @Component (@Service/@Repository/@Controller) when you want to create a bean of a class which is under your control.
 - Example of a scenario where we need the use of @Bean: Suppose you want a service to connect to two different Databases or Repositories, Production and Staging. You have two different classes for the two different databases. With the normal @Autowired annotation, you'll be unable to create two different objects of that same service class for two different purposes. Hence, you use @Bean("<custom_bean_name>") annotation, one for prod and one for staging purpose, to create two different objects of that service class.
 - Cookies and sessions are used by websites to store user's data (user's info, permissions, history, etc.) across multiple requests, multiple pages of a site, multiple sessions, multiple tabs, multiple browsers, multiple devices, multiple logins, multiple computers, multiple networks, multiple locations, multiple time zones, multiple countries, multiple continents, etc. Cookies may also contain values sent by server to the client (eg., token). The key difference between sessions and cookies is that sessions are saved on the server side while cookies are saved on the client side (eg., user's web browser). Then browser, by default, attaches the cookies (in the request's header) to every request user makes to a particular server.
   Sessions are more secure than cookies as it is stored on the server side. Cookies stored data in text file. Session save data in encrypted form.
 - CORS (Cross Origin Resource Sharing): It is used to tell the browser to allow the client to access the resources of the server from a different origin. For eg., client makes a call to 'X' website and 'X' website makes a call to 'Y' website, where the origin of the request is not of website 'Y' it's of the client itself. Here, the client has no knowledge of his request being made to a different origin (website 'Y') internally, while making a request to website 'X', hence, we must let the user know and ask for user's permission to make that call to a different origin server for him. So like this, CORS is used to allow the client to access the resources of the server from a different origin.
   Remember, the CORS request is a client's request to the third-party server of a different origin and NOT the second-party server's request to the third-party server of different origin.
 - Spring Authorization Server Library: It's a framework that provides implementations for the OAuth 2.1 and OpenID Connect protocols. It is used to create an authorization server. It is used to authenticate the user and provide the access token to the client. The client uses the access token to access the resources of the resource server.
 - OAuth 2.0 Client Credentials Grant: The Client Credentials grant type is used by clients to obtain an access token outside of the context of a user. This is typically used by clients to access resources about themselves rather than to access a user's resources.
 - Spring provides the following interfaces for us to implement:
    - UserDetails: used to provide the user's data to the spring security
    - UserDetailsService: used to load the user's data from the database
    - GrantedAuthority: used to provide the user's roles (or any parameter which is being used as an authority) to the spring security.
 - When we use hasAuthority("<role-name>") method in the default security configuration using granted authorities, spring does not know how to convert the user's role name (which is present in the JWT's "claims" part), for checking and granting the authority to that user. Hence, we need to create a custom converter for the same, which implements the Converter<Jwt, AbstractAuthenticationToken> interface.
 - Summary of interaction between User and Product service:
    - SignUp: User ----> Auth Server
    - Login: User ----> Auth Server
    - Sharing of token: Auth Server ---> User
    - Request resource with the shared token: User ----> Resource Server (Product Service) "/products/*"
        - If Token Valid:
            - If role matches: ALLOW
            - Else: DENY
        - If Token invalid: DENY

DEPLOYMENT ON CLOUD (AWS)

 - EC2 (Elastic Compute Cloud): It is a web service that provides secure, resizable compute capacity in the cloud. It provides the virtual servers in the cloud.
 - RDS (Relational Database Service): It is a web service that provides the relational database in the cloud (eg., MySql, etc.). It provides the managed database in the cloud.
 - Elastic Beanstalk: To quickly deploy and manage applications in the AWS Cloud without having to learn about the infrastructure that runs those applications. It thus reduces management complexity without restricting choice or control. You simply upload your application (your project's JAR file), and Elastic Beanstalk automatically handles the details of capacity provisioning, load balancing, scaling, and application health monitoring.
    - How to create a JAR file: Go to maven panel -> Lifecycle -> double click on package (you can toggle 'Skip Tests' mode before doing this). The JAR file will be created in the target folder of the project.
 - Instance profile: Just like roles (collection of permissions via policies) get attached to an IAM user to grant/revoke resource access rights to a particular user, instance profiles are roles that get attached to instances.
 - Security Groups: Set of rules to control inbound and outbound traffic for an instance. Security groups act at the instance level, not the subnet level. Therefore, each instance in a subnet in your VPC can be assigned to a different set of security groups.
 - Create RDS and make the datasource configurations accordingly in your application.properties file.
 - Spring Boot Actuator: It is a sub-project of Spring Boot. It adds several production grade services (like monitoring our app, gathering metrics, and understanding traffic or the state of our database, etc.) to your application with little effort on your part. In this case, we are using it to monitor the health of our application.
 - Beanstalk's environment variables: It is used to store sensitive information (like database username, password, etc.), configuration information (like database URL, port, etc.), environment specific information (like environment name, environment id, etc.), application specific information (like application name, application version, etc.), etc. We then use these environment variables in our application.properties file via property placeholders. Similarly, we can configure environment variables in our local machine as well. We can do this by going to the run configuration of our project in the IDE and then adding the environment variables in the environment variables section.
 - VPC (Virtual Private Cloud): It is a virtual network dedicated to your AWS account. It is logically isolated from other virtual networks in the AWS Cloud. You can launch your AWS resources, such as EC2 instances, into your VPC. You can then configure the security groups and network access control lists to provide secure and controlled access to your instances.

---------------------------------------------ADVANCE-----------------------------------------------------

PAYMENT

 - Interaction between the client, order and payment service:
    1) The client (via the frontend page of a website) orders a product from the product service. Product service provides the productId and the payment details back to the client.
    2) Client then requests to pay for his order which consist of the product he wants to purchase. The productId against that orderId is then provided to the payment service.
    3) The payment service verifies the product with the product service against the productId.
    4) After successful verification, the payment service makes a call to its preferred payment gateway (RazorPay or Stripe) which it has chosen and selected, asking for a link to the payment page.
    5) This link is then provided back to the client. The client then makes the payment through this link.
    6) Payment details gets updated (via webhook) in the payment service.
    7) Order details gets updated (after validation) in the order service

 - Now, how will the website know that the payment made through the link provided by the payment gateway was successful or not?
    1) It will be known through a callback URL. Callback URL is a URL which will be provided by the website to the payment gateway.
    2) The payment gateway will send a POST request to the website's callback URL with the payment details of that order (like payment status (success/failure), orderId, etc.).
    3) The website will then call the payment service to update the payment details against the said orderId and validate it with the order service (because 1 order can have multiple payments, hence, we need to check complete payment has been made for that order).
    4) On successful validation, the order service will update the order status to "PAID".
    5) Now, the website will also update the order status to "PAID".
 - To increase assurance regarding payment details, along with the concept of callback URL we shall use the concept of Webhook too. So instead of completely relying on the callback URL, we can also get the payment related details via webhook. Hence, increases reliability and reduces dependency on frontend.
 - Webhook URL/API: A URL or an API which the payment service REST API will provide to the payment gateway, so that instead of website making a call to the payment service (3rd step in the above mentioned steps), the payment gateway can directly call the payment service's webhook URL/API.
 - LocalTunnel: It is a tool which allows you to expose your localhost to the internet. It is used to expose the webhook URL/API of the payment service to the payment gateway. This is done because the payment gateway needs to make a call to the webhook URL/API of the payment service.
                  1) Start a webserver on some local port (eg http://localhost:9000) and use the command line interface to request a tunnel to your local server: lt --port 9000
                  2) You will receive a url, for example https://flkajsfljas.loca.lt, that you can share with anyone (here, the payment gateway) for as long as your local instance of lt remains active. Any requests will be routed to your local service at the specified port.

 - For implementation of creating a payment link in your code, follow the 3rd party payment gateway documentation on their website.
 - In order to have a RazorPay client, you need to have a RazorPay account. After creating an account (not a business account a software developer's one), you will get a key_id and key_secret. These keys are used to authenticate the client with the RazorPay server. You can then use these keys to create a RazorPay client.
 - Idempotency in Computer Science: It is the principle where an operation can be performed multiple times without changing the result beyond the initial application. It is important in the context of payment gateways because if the payment gateway makes a call to the webhook URL/API of the payment service and the payment service is down, then the payment gateway will make the call again and again until the payment service is up. In this case, the payment service should not process the same request again and again. It should process the request only once. Hence, the payment gateway should send an idempotency key with the request to the webhook URL/API of the payment service. The payment service should check the idempotency key and process the request only once. The payment gateway should generate a new idempotency key for each request.






